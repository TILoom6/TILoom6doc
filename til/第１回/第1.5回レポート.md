# 第1.5回レポート





# 今回の主催

吉岡

# 時間

2h

# 前回の勉強会で議論したこと
- 問題へのアプローチ
  - 問題の分解の仕方
- 分解した問題をクラス設計に落とし込むには（半分）
# 議論したこと
- 分解した問題をクラス設計に落とし込むには（8割）
# 議論できなかったこと
- 分解した問題をクラス設計に落とし込むには（あと2割）
  - JSONが強かった
- 最終的な設計に対する評価
# やったこと
## 分解した問題をクラス設計に落とし込むには
- Parseしたログを保持するクラスの立ち位置
  - 結論：純粋にデータだけをもつ
    - ソートとかデータ操作は、本来であればOpViewerがやるべきこと
    - このブリッジライブラリは数年にわたって運用を続ける前提がある以上、OpViewerの改修が発生する可能性がある
    - そうなったときにソートとかのデータ操作機能は手軽に捨てられるようにしたい
![採用されたログオブジェクトの設計（右側）](https://d2mxuefqeaa7sj.cloudfront.net/s_FDB0AC38843A3E55E4F08944FC22DF67B3732BBFDB96E9907D15F11A09BBFA33_1507964065738_2017-10-11+19.36.14.jpg)

  - ボツ案
    - データだけでなく、抽象的なデータ操作（ソートする等）をもったクラスにする（DB的な）
      - 上記で今回の要件にそった振る舞いを実装するためにクエリクラスも作って何順でソートするかはそのクラスの責務にする
      - → YAGNI原則（余計なことをしてもきっと無駄になる原則）によって却下
- 表示文字列に置き換え
  - 前提：パースしたレコードの各アイテムはすべて文字列（問題をかんたんにするために生まれた前提）
  - 以下の責務に分解してクラス設計
    - ログの各レコードに変換を適用する
    - 変換クラスを生成する
    - 変換する対象（カラム）を抜き出す
    - 変換を適用する
      - 変換する対象（カラム）を抜き出す、変換を適用する は一つの責務じゃね？ という議論が発生したが、変換対象を知っているという知識と、何を何に変換するという知識は別物ということで分けた
![表示文字列変換の設計結果](https://d2mxuefqeaa7sj.cloudfront.net/s_FDB0AC38843A3E55E4F08944FC22DF67B3732BBFDB96E9907D15F11A09BBFA33_1507964658392_2017-10-11+20.23.23.png)

- JSON化
  - やることが存外巨大なので、一旦JSON化を機能分解した
    - 出題者もこの辺深く考えてなかった。てへぺろ
  - まずJSONを表現するデータクラスの形を定義
    - デザインパターンのComposite patternを適用
      - https://ja.wikipedia.org/wiki/Composite_パターン
    - Object以外は、自身の属性名（プロパティ名）をもつ
    - プリミティブ値以外は、配下の値への参照を持つ
![](https://d2mxuefqeaa7sj.cloudfront.net/s_FDB0AC38843A3E55E4F08944FC22DF67B3732BBFDB96E9907D15F11A09BBFA33_1507964021724_2017-10-11+20.57.27.jpg)


ここまで考えて時間切れ。
次回へ続く。

